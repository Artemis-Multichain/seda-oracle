This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-11-06T12:42:26.346Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
.devcontainer/
  devcontainer.json
  Dockerfile
assembly/
  execution-phase.ts
  index.ts
  tally-phase.ts
  tsconfig.json
scripts/
  post-dr.ts
tests/
  index.test.ts
.env.example
.gitignore
asconfig.json
LICENSE
package.json
README.md
tsconfig.json

================================================================
Repository Files
================================================================

================
File: .devcontainer/devcontainer.json
================
{
  "name": "seda-request-starter-kit",
  "build": {
    "dockerfile": "Dockerfile",
    "args": {
      "VARIANT": "1.1.20"
    }
  },
  "features": {
    "node": {
        "version": "lts",
        "nodeGypDependencies": true
    }
  },
  "customizations": {
    "vscode": {
      "settings": {},
      "extensions": [
        "EditorConfig.EditorConfig",
        "dbaeumer.vscode-eslint",
        "esbenp.prettier-vscode",
        "dtsvet.vscode-wasm"
      ]
    }
  },
  "postCreateCommand": "bun install"
}

================
File: .devcontainer/Dockerfile
================
ARG VARIANT=latest
FROM oven/bun:${VARIANT}

RUN apt-get update \
    && apt-get -y install --no-install-recommends \
    git \
    nano \
    unzip \
    vim-tiny \
    ssh \
    && apt-get auto-remove -y \
    && apt-get clean -y \
    && chsh -s $(which bash) bun \
    && echo 'export PS1="\e[01;32m\u\e[m:\e[01;34m\w\e[m\$ "' >> /home/bun/.bashrc

USER bun

================
File: assembly/execution-phase.ts
================
import {
  Bytes,
  Console,
  Process,
  httpFetch,
} from '@seda-protocol/as-sdk/assembly';

@json
class ValidationResponse {
  status!: string;
  message!: string;
  result!: string;
}

export function executionPhase(): void {
  const drInputsRaw = Process.getInputs().toUtf8String();
  Console.log(`Verifying transaction: ${drInputsRaw}`);

  // Parse chainId and txHash from input
  const drInputs = drInputsRaw.split('-');
  if (drInputs.length !== 2) {
    Process.error(
      Bytes.fromUtf8String('Invalid input format. Expected: chainId-txHash')
    );
    return;
  }

  const chainId = drInputs[0];
  const txHash = drInputs[1];

  Console.log(`Validate Transaction Status`);

  const response = httpFetch(
    `https://seda-oracle-production-317f.up.railway.app/proxy/?chainid=${chainId}&module=transaction&action=gettxreceiptstatus&txhash=${txHash}`
  );

  if (!response.ok) {
    Console.error(
      `HTTP Response was rejected: ${response.status.toString()} - ${response.bytes.toUtf8String()}`
    );
    Process.error(
      Bytes.fromUtf8String('Error while fetching transaction status')
    );
    return;
  }

  const data = response.bytes.toJSON<ValidationResponse>();

  if (data.message !== 'OK') {
    Process.error(
      Bytes.fromUtf8String(
        `Status: Transaction Cannot be Validated ${data.result}`
      )
    );
  } else {
    Process.success(
      Bytes.fromUtf8String(
        `Status: Transaction Validated Successfully ${data.result}`
      )
    );
  }
}

================
File: assembly/index.ts
================
import { executionPhase } from './execution-phase';
import { tallyPhase } from './tally-phase';
import { OracleProgram } from '@seda-protocol/as-sdk/assembly';

/**
 * Defines a transaction verification oracle program that performs two main tasks:
 * 1. Verifies transaction status using Etherscan API during execution phase
 * 2. Aggregates the results from multiple executors in the tally phase to reach consensus
 */
class TransactionVerifier extends OracleProgram {
  execution(): void {
    executionPhase();
  }

  tally(): void {
    tallyPhase();
  }
}

// Runs the transaction verification oracle program by executing both phases
new TransactionVerifier().run();

================
File: assembly/tally-phase.ts
================
import { Tally, Process, Bytes, u128, Console } from "@seda-protocol/as-sdk/assembly";

export function tallyPhase(): void {
  const reveals = Tally.getReveals();
  const results: string[] = [];

  // Collect all status strings from reveals
  for (let i = 0; i < reveals.length; i++) {
    const result = reveals[i].reveal.toUtf8String();
    results.push(result);
  }

  if (results.length === 0) {
    Process.error(Bytes.fromUtf8String('No results revealed'));
    return;
  }

  // Check if all results are the same
  const firstResult = results[0];
  let consensus = true;
  for (let i = 1; i < results.length; i++) {
    if (results[i] !== firstResult) {
      consensus = false;
      break;
    }
  }

  if (!consensus) {
    Process.error(Bytes.fromUtf8String('No consensus on transaction status'));
    return;
  }

  // Return consensus result
  Process.success(Bytes.fromUtf8String(firstResult));
}

================
File: assembly/tsconfig.json
================
{
  "extends": "assemblyscript/std/assembly.json",
  "include": ["./**/*.ts"]
}

================
File: scripts/post-dr.ts
================
// scripts/post-dr.ts
import {
  Signer,
  buildSigningConfig,
  postAndAwaitDataRequest,
} from '@seda-protocol/dev-tools';

async function main() {
  if (!process.env.ORACLE_PROGRAM_ID) {
    throw new Error('Please set the ORACLE_PROGRAM_ID in your env file');
  }

  const signingConfig = buildSigningConfig({});
  const signer = await Signer.fromPartial(signingConfig);

  // Example transaction verification request
  const chainId = '84532'; // Base Sepolia
  const txHash =
    '0x1b2aa6906b83251aecf9beb5c1e0ff815d4c7f0ac27cc3df474e0117dd8c3f6c';
  const drInput = `${chainId}-${txHash}`;

  console.log('Posting transaction verification request...');
  console.log(`Chain ID: ${chainId}`);
  console.log(`Transaction Hash: ${txHash}`);

  const result = await postAndAwaitDataRequest(
    signer,
    {
      consensusOptions: {
        method: 'none',
      },
      oracleProgramId: process.env.ORACLE_PROGRAM_ID,
      drInputs: Buffer.from(drInput),
      tallyInputs: Buffer.from([]),
      memo: Buffer.from(new Date().toISOString()),
    },
    {}
  );

  // Display the result
  console.log('\nVerification Result:');
  console.log(result.result.toString());
  console.table({
    'Chain ID': chainId,
    'Transaction Hash': txHash,
  });
}

main();

================
File: tests/index.test.ts
================
import { afterEach, describe, it, expect, mock } from "bun:test";
import { file } from "bun";
import { testOracleProgramExecution, testOracleProgramTally } from "@seda-protocol/dev-tools"
import { BigNumber } from 'bignumber.js'

const WASM_PATH = "build/debug.wasm";

const fetchMock = mock();

afterEach(() => {
  fetchMock.mockRestore();
});

describe("data request execution", () => {
  it("should aggregate the results from the different APIs", async () => {
    fetchMock.mockImplementation((url) => {
      if (url.host === "api.binance.com") {
        return new Response(JSON.stringify({ price: "2452.30000" }));
      }

      return new Response('Unknown request');
    });

    const oracleProgram = await file(WASM_PATH).arrayBuffer();

    const vmResult = await testOracleProgramExecution(
      Buffer.from(oracleProgram),
      Buffer.from("eth-usdc"),
      fetchMock
    );

    expect(vmResult.exitCode).toBe(0);
    // BigNumber.js is big endian
    const hex = Buffer.from(vmResult.result.toReversed()).toString('hex');
    const result = BigNumber(`0x${hex}`);
    expect(result).toEqual(BigNumber('2452300032'));
  });

  it('should tally all results in a single data point', async () => {
    const oracleProgram = await file(WASM_PATH).arrayBuffer();

    // Result from the execution test
    let buffer = Buffer.from([0, 33, 43, 146, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
    const vmResult = await testOracleProgramTally(Buffer.from(oracleProgram), Buffer.from('tally-inputs'), [{
      exitCode: 0,
      gasUsed: 0,
      inConsensus: true,
      result: buffer,
    }]);

    expect(vmResult.exitCode).toBe(0);
    const hex = Buffer.from(vmResult.result).toString('hex');
    const result = BigNumber(`0x${hex}`);
    expect(result).toEqual(BigNumber('2452300032'));
  });
});

================
File: .env.example
================
# RPC for the SEDA network you want to interact with
SEDA_RPC_ENDPOINT=https://rpc.devnet.seda.xyz

# Your SEDA chain mnemonic, fill this in to upload binaries or interact with data requests directly
SEDA_MNEMONIC=

# Used for posting data request on the seda chain and configuring the consumer contract
# You can get this by running `bunx seda-sdk wasm upload PATH_TO_BUILD`
ORACLE_PROGRAM_ID=

================
File: .gitignore
================
.env
node_modules
build

# Hardhat files
/cache
/artifacts

# TypeChain files
/typechain
/typechain-types

# solidity-coverage files
/coverage
/coverage.json

# Hardhat Ignition default folder for deployments against a local node
ignition/deployments/chain-31337

.DS_Store

================
File: asconfig.json
================
{
  "extends": "./node_modules/@assemblyscript/wasi-shim/asconfig.json",
  "targets": {
    "debug": {
      "outFile": "build/debug.wasm",
      "textFile": "build/debug.wat",
      "sourceMap": true,
      "debug": true
    },
    "release": {
      "outFile": "build/release.wasm",
      "textFile": "build/release.wat",
      "sourceMap": true,
      "optimizeLevel": 3,
      "shrinkLevel": 0,
      "converge": false,
      "noAssert": false
    }
  },
  "options": {
    "bindings": "esm",
    "transform": ["json-as/transform"]
  }
}

================
File: LICENSE
================
MIT License

Copyright (c) 2024 SEDA protocol

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: package.json
================
{
  "name": "seda-request-starter-kit",
  "version": "0.0.1",
  "description": "",
  "type": "module",
  "scripts": {
    "build": "asc ./assembly/index.ts --target release",
    "build:debug": "asc ./assembly/index.ts --target debug",
    "deploy": "bun run build && bunx seda-sdk oracle-program upload ./build/release.wasm",
    "deploy:debug": "bun run build:debug && bunx seda-sdk oracle-program upload ./build/debug.wasm",
    "post-dr": "bun run ./scripts/post-dr.ts",
    "test": "bun run build:debug && bun test"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "@seda-protocol/dev-tools": "^0.0.13",
    "@types/bun": "^1.1.6",
    "assemblyscript": "^0.27.29",
    "bignumber.js": "^9.1.2"
  },
  "dependencies": {
    "@seda-protocol/as-sdk": "^0.0.16",
    "@seda-protocol/vm": "^0.0.4"
  }
}

================
File: README.md
================
<p align="center">
  <a href="https://seda.xyz/">
    <img width="90%" alt="seda-protocol" src="https://www.seda.xyz/images/footer/footer-image.png">
  </a>
</p>

<h1 align="center">
  SEDA Request Starter Kit
</h1>

This starter kit helps you create Data Requests (also known as Oracle Programs) on the SEDA network using AssemblyScript. It showcases a basic project setup and serves as a foundation for building more complex projects.

## Requirements

- **Bun**: Install [Bun](https://bun.sh/) for package management and building.
- Alternatively, use the [devcontainer](https://containers.dev/) for a pre-configured environment.

## Getting Started

A Data Request execution involves two phases executed in a WASM VM:

1. **Execution Phase**: The phase where non-deterministic operations occur. It can access public data via `http_fetch` or `proxy_http_fetch` calls. Multiple executor nodes run this phase and submit their reports to the SEDA network.

2. **Tally Phase**: Aggregates reports from the execution phase using custom logic to determine a final result.

> [!NOTE]
> This starter kit uses the same Oracle Program for both phases, but you can specify different binaries and add branching logic if needed.

### Building

To build the Oracle Program, run the following (builds using the release profile by default):

```sh
bun run build
```

To build the Oracle Program with the debug profile, run:

```sh
bun run build:debug
```

### Local Testing

To test the Oracle Program, this project uses `@seda-protocol/vm` and `@seda-protocol/dev-tools`. These tools help run the Oracle Program in a local WASM VM and test different scenarios.

This project uses Bun's built-in test runner, but other JavaScript/TypeScript testing frameworks should also work.

> [!WARNING]
> The `@seda-protocol/vm` package might not work properly in Node.js. Try setting the environment variable `NODE_OPTIONS=--experimental-vm-modules` before running the test command.

```sh
bun run test
```

## Implement your Oracle Program

Use these key components to create and define your Oracle Program. The starter kit provides a base for building Oracle Programs on the SEDA network:

- **`assembly/index.ts`**: The entry point that coordinates both the execution and tally phases of your Data Request.

- **`assembly/execution-phase.ts`**: Manages the fetching and processing of price data from APIs. This phase involves non-deterministic operations as it can access public data via `http_fetch` and `proxy_http_fetch` calls. Multiple Executor Nodes run this phase, each producing a report that is sent to the SEDA network.

- **`assembly/tally-phase.ts`**: Aggregates results from multiple Executor reports and calculates the final output using consensus data. This phase is deterministic, combining results from Executor Nodes to reach a consensus.

### Utilities and Functions

The following are some of the key utilities and functions from the `@seda-protocol/as-sdk/assembly` library used in the example provided in this starter kit. These tools help you build and define your Oracle Program. While these are a few important ones, the SDK offers additional utilities to explore:

- **`Process`**: Manages inputs and outputs, allowing interaction with the WASM VM.
- **`http_fetch`**: Fetches data from public APIs.
- **`Console`**: Provides logging capabilities to debug and track the execution of your code.
- **`JSON`**: Facilitates parsing and handling JSON data.
- **`Bytes`**: Assists in working with byte arrays, useful for encoding and decoding data.

These components and utilities serve as a foundation for developing your Oracle Program logic. For a complete list of utilities and advanced usage, refer to the official documentation.

## Interacting with SEDA Networks

You can upload Oracle Programs and interact with the SEDA network using the CLI tools provided by `@seda-protocol/dev-tools`.

### Uploading an Oracle Program

To upload an Oracle Program binary, run:

```sh
bun run deploy
```

> [!IMPORTANT]  
> This command requires `RPC_SEDA_ENDPOINT` and `MNEMONIC` environment variables.

Alternatively, you can directly use the CLI to upload an Oracle Program and list existing binaries.

List existing Oracle Programs (requires `RPC_SEDA_ENDPOINT` environment variable):

```sh
# With .env file
bunx seda-sdk oracle-program list
# With flag
bunx seda-sdk oracle-program list --rpc https://rpc.devnet.seda.xyz
```

Upload an Oracle Program (requires `RPC_SEDA_ENDPOINT` and `MNEMONIC` environment variables):

```sh
bunx seda-sdk oracle-program upload PATH_TO_BUILD
```

### Submitting a Data Request

`@seda-protocol/dev-tools` exposes functions that make it easy to create scripts that submit Data Requests to the SEDA network and await the result. The `scripts` directory shows an example.

Submitting a Data Request to the SEDA network, run:

```sh
bun run post-dr
```

This will post a transaction and wait till there is an result.

> [!IMPORTANT]  
> Make sure you have the all environment variables set in `.env` file.


Example of an `.env` file:

```sh
# RPC for the SEDA network you want to interact with
SEDA_RPC_ENDPOINT=https://rpc.devnet.seda.xyz

# Your SEDA chain mnemonic, fill this in to upload binaries or interact with data requests directly
SEDA_MNEMONIC=

# Used for posting data request on the seda chain and configuring the consumer contract
# You can get this by running `bunx seda-sdk oracle-program upload PATH_TO_BUILD`
ORACLE_PROGRAM_ID=
```

## License

Contents of this repository are open source under [MIT License](LICENSE).

================
File: tsconfig.json
================
{
    "exclude": ["node_modules"],
    "compilerOptions": {
        "module": "NodeNext",
        "moduleResolution": "NodeNext"
    }
}
